<html>
<head>
<title>TFM Tournament</title>
<!--<link href="https://unpkg.com/tabulator-tables@4.2.3/dist/css/tabulator.min.css" rel="stylesheet">-->
<!--<link href="tabulator_simple.css" rel="stylesheet">-->
<!-- <script type="text/javascript" src="tabulator.min.js"></script> -->
<link href="https://unpkg.com/tabulator-tables/dist/css/tabulator.min.css" rel="stylesheet">
<script type="text/javascript" src="https://unpkg.com/tabulator-tables/dist/js/tabulator.min.js"></script>
<link rel="stylesheet" href="css/bootstrap.min.css">
<script src="js/jquery.min.js"></script>
<script src="js/jquery-ui.min.js"></script> <!-- dialogs -->
<link rel="stylesheet" href="css/jquery-ui.css" />
<script src="js/bootstrap.min.js"></script>
</head>
<body>


<ul id="tabPane" role="tablist" class="nav nav-tabs">
	<li class="nav-item active"><a data-toggle="tab" href="#playerTabPane" role="tab" class="nav-link active playerTab">Player</a></li>
	<li class="nav-item"><a data-toggle="tab" href="#matchTabPane" role="tab" class="nav-link matchTab">Match</a></li>
	<li class="nav-item"><a data-toggle="tab" href="#googleResultTabPane" role="tab" class="nav-link googleResultTab">GoogleResult</a></li>
	<li class="nav-item"><a data-toggle="tab" href="#scoreTabPane" role="tab" class="nav-link scoreTab">Score</a></li>
	<li class="nav-item"><a data-toggle="tab" href="#corpTabPane" role="tab" class="nav-link corpTab">Corps</a></li>
	<!--<li class="nav-item"><a data-toggle="tab" href="#raffleTabPane" role="tab" class="nav-link raffleTab">Raffle</a></li>-->
	<li class="nav-item"><a data-toggle="tab" href="#helpTabPane" role="tab" class="nav-link helpTab">Help</a></li>
</ul>

</br>

<div class="tab-content">
	<div role="tabpanel" id="playerTabPane" class="tab-pane active">
		<div class="table-controls">
		<button id="player-add">Add Player</button>
		<button id="download-player-json">Download JSON</button>
		<button id="load-player-json">Load JSON</button>
		<button id="load-player-csv">Load CSV</button>
		<button id="player-check">Check Player</button>
		</div>
		</br>
		<div id="player_count">Total Players:</div> <!-- includes inactive players -->
		<div id="active_count">Active Players:</div>
		</br>
		<div id="player-table"></div>
	</div>

	<div role="tabpanel" id="matchTabPane" class="tab-pane">
		At round: <div id="round-indicator" style="display: inline-block"></div>
		<div class="table-controls">
			<button id="start-new-round">Start New Round</button>
		</div>
		</br>
		<div class="table-controls">
			<button id="history-undo">Undo Edit</button>
			<button id="history-redo">Redo Edit</button>
			<button id="add-match-row">Add Row</button>
			<button id="del-match-row">Delete Rows</button>
			<!--<button id="download-match-csv">Download CSV</button>-->
			<button id="filter-errors">Filter Errors</button>
			<button id="download-match-json">Download JSON</button>
			<button id="load-match-json">Load JSON</button>
			<span id="history-msg" style="margin-left:10px; font-weight:bold;"></span>
		</div>
		</br>
		<div id="match-table"></div>
	</div>
	
	
	<div role="tabpanel" id="googleResultTabPane" class="tab-pane">
		Autoloads columns, make sure code is up to date with columns
		<div class="table-controls">
			<button id="load-result-csv">Load CSV</button>
			<button id="load-result-json">Load JSON</button>
			<button id="download-result-json">Save JSON</button>
			<button id="del-result-row">Delete row</button>
			<button id="merge-into-match">DANGER! Merge into Match</button>
			<span id="history-msg" style="margin-left:10px; font-weight:bold;"></span>
		</div>
		</br>
		<div id="googleresult-table"></div>
	</div>
	

	<div role="tabpanel" id="scoreTabPane" class="tab-pane">
		<div class="table-controls">
			<button id="compute-score">Calculate Scores & Rank</button>
			<button id="download-score-json">Download JSON</button>
			<button id="Lottery">Lottery</button>
			<!--<button id="download-score-pdf">Export PDF</button> WIP -->
		</div>
		</br>
		<div id="score-table"></div>
	</div>

	<div role="tabpanel" id="corpTabPane" class="tab-pane">
		<div class="table-controls">
			<button id="compute-corp">Calculate Scores & Rank</button>
			<button id="download-corp-json">Download JSON</button>
		</div>
		</br>
		<div id="corp-table"></div>
	</div>

	<div role="tabpanel" id="helpTabPane" class="tab-pane">
		</br>
		<ul>
		<li><h3>Player leaves tournament</h3></li>
		<p>Go to Player tab, find the player and turn off present so that a red cross (X) shows. If the player was already at a table then change the table number and fill a 4 in Rank.</p>
		<li><h3>Player is late to the tournament</h3></li>
		<p>Go to Player tab, and make sure that the player is present (green). Then, on the Match tab, click on Start New Round. It will detect a missing player and at the bottom rows are added for this player. If the player participated at a table then fill in his/her table as well as scores. If the player did not enter any table for a round, then fill in a table number that is not existing (e.g. 40) and fill in a score of 0.</p>
		<li><h3>Player joined wrong table</h3></li>
		<p>Look up the player in the Match table, change his/her Table number to the table he/she joined and check who took his/her spot at the original table.</p>
		<li><h3>Player has wrong VP or Rank</h3></li>
		<p>Look up the player in the Match table, change his/her VP and Rank to the correct one. Then in the Score tab, click on Calculate Score & Rank. In future rounds the updated score is used.</p>
		<li><h3>Warning: Who is better?</h3></li>
		<p>Look up the players mentioned in the Match table, change their VP and Rank to the correct one. Then in the Score tab, click on Calculate Score & Rank. In future rounds the updated score is used.</p>
		<li><h3>Warning: Not all scores are entered</h3></li>
		<p>Make sure all VPs (and if necessary, then also ranks) are entered before hitting the start new round.</p>
		<li><h3>What is ...?</h3></li>
		<p>VP = Victory Points, the final points in a match. Pts = Match points, 3, 2, 1 or 0 points are awarded based on the rank in the game. Rank is first, second, third or fourth place within a match, being first is best.</p>
		<li><h3>Player matched to the same opponent</h3></li>
		<p>There is a slight but unfortunate chance that a player is matched to the same opponent twice.</p>
		<li><h3>What is button ...?</h3></li>
		<p>Add Player / Remove Player are obvious. Undo edit makes you undo the latest edit. Redo edit redoes the edit after you first did undo edit. Download csv evidently downloads the table. Calculate scores & rank rebuilds the scoring table from scratch, including the tournament sorting.</p>
		</ul>
	</div>
</div>


</body>
<script type="text/javascript">

// TOURNAMENT Setup
// tournament variables
var TOURNAMENT_MAX_ROUNDS = 3; // how many rounds we play
var rank_scores = [3,3,2,1,0,0,0,0]; // corresponding to rank 1,2,3,4,5,6 (in case that somehow 5th/6th player happened to join the same table. Starts from rank 1 so skips first value as dummy (=3)
var MAX_ATTEMPTS_ASSIGNTABLES = 100; // how many attempts it makes at making  a suitable table assignment for a round

// PLAYER SETUP
//var init_players_tournament = []
//var init_players = [];
// for (i in init_players_tournament) {
//	//init_players.push({"id":parseInt(i), "player":init_players_tournament[i].player, "present":true, "paid":init_players_tournament[i].paid || false});
//	init_players.push({"id":parseInt(i), "player":init_players_tournament[i], "present":false, "paid":true});
//};
//var highest_playerid = init_players.length;
var highest_playerid = 0; // initial value
function addIncrementingIds(row) {
  if (row.getData().id === undefined) {
    highest_playerid++;
    row.getCell("id").setValue(highest_playerid); // Set the ID column value
  }
}
var playerTable = new Tabulator("#player-table", {
	//data:init_players,
	//ajaxURL:"playerData_NK2023.json", # we load manually
	//addRowPos:"top",
	//autoColumns:true, // this doesnt work well as it also overrides my settings // but if you load csv then it should ignore the columns
	downloadRowRange:"all",
	//persistenceID:"playertable1",
	//persistence: true,
	//reactiveData:true,
	history:true,
	selectable:true,
	layout:"fitDataFill",
    columns:[
		{title:"ID", field:"id", width:50, editor:"number"},
		{title:"Player", field:"player", width:200, editor:"input"},
		{title:"Present", field:"present", width:100, hozAlign:"center", formatter:"tickCross", editor:true},
    ]
});
function rectifyPlayerTable() {
	// Because loading as CSV can autocolumn integers to string
	var dataToUpdate = playerTable.getData().map(function (row) {
	  return {
		id: parseFloat(row.id) || row.id,
		player: row.player,
		present: typeof row.present === 'boolean' ? row.present : row.present.toLowerCase() === "true" ? true : false
	  };
	});
	playerTable.setData(dataToUpdate);
};
function getMaxPlayerID() {
	let data = playerTable.getData();
	let maxID = 0; // Default to 0
	data.forEach(function (row) {
		if (typeof row.id === 'number' && !isNaN(row.id)) {
		  maxID = Math.max(maxID, row.id);
		}
	});
	return maxID;
};
highest_playerid = getMaxPlayerID(); // after initialization
// Retrieve the name of a player given an ID
function retrievePlayer4ID(id) {
	//console.log(id);
	let playerData = playerTable.getData();
	let matchingPlayer = playerData.find(function(el) { return el.id === id });
	// Return the player's name if found, or an empty string if not found
	return matchingPlayer ? matchingPlayer.player : '';	
};
// Retrieve list of active player IDs
function getActivePlayers() {
	return Array.from(playerTable.getData().filter(r => r.present == true), v => v["id"]);
}
function updatePlayerCounts() {
	rectifyPlayerTable();
	highest_playerid = getMaxPlayerID();
	$("#player_count").text('Total Players: '+highest_playerid);
	$("#active_count").text('Active Players: '+getActivePlayers().length);
};
//Add row on "Add Row" button click //can be improved by reopening the window message
$("#player-add").click(function(){
	updatePlayerCounts();
	let newplayer = prompt("Please enter a name", "");
	if (newplayer != null) {
		let playerList = Array.from(playerTable.getData(), v => v["player"]);
		if ( !playerList.includes(newplayer) ) {
			highest_playerid++;
			playerTable.addRow({"player":newplayer, "id":highest_playerid, "present": true});
			updatePlayerCounts();
		} else {
			window.alert('Player already exists. Change name to differentiate players.');
		};
	};
});
//Delete row on "Delete Row" button click TURNED OFF AS PRECAUTION
//$("#player-del").click(function(){
//	let selectedRows = playerTable.getSelectedRows();
//	for(let i=0;i<selectedRows.length;i++) { selectedRows[i].delete(); }
//	updatePlayerCounts();
//});
//Clear table on "Empty the table" button click
$("#player-clear").click(function(){ playerTable.clearData(); });
//undo button
$("#player-history-undo").click(function(){ playerTable.undo(); });
//redo button
$("#player-history-redo").click(function(){ playerTable.redo(); });
//trigger download of data.json file
$("#download-player-json").click(function(){ playerTable.download("json", "playerData "+Date().toLocaleString().replace(/(:|GMT.*)/gm, '')+".json"); });
//load json file
$("#load-player-json").click(function(){ 
	playerTable.import("json", ".json")
		.then(function() {
            // This code will execute after the import operation is completed
            updatePlayerCounts();
        })
        .catch(function(error) {
            // Handle any errors that occur during the import
            console.error("Error importing CSV:", error);
        });
});
$("#load-player-csv").click(function(){ 
	playerTable.import("csv", ".csv")
		.then(function() {
            // This code will execute after the import operation is completed
            updatePlayerCounts();
        })
        .catch(function(error) {
            // Handle any errors that occur during the import
            console.error("Error importing CSV:", error);
        });
});
$("#player-check").click(function(){
	updatePlayerCounts();
});

// MATCH TAB
//var matchData = [];
var matchrowid = 0;
var matchTable = new Tabulator("#match-table", {
	index: "id",
	//data:matchData,
	//layout:"fitDataFill",
    //height:"311px",
	layout:"fitColumns",
	//resizableColumns:false,
	movableRows:true,
	reactiveData:true,
	history:true,
	downloadRowRange:"all",
	persistenceID:"matchtable1",
	persistence: true,
	selectable: 1, // 1 means max 1 can be selected at a time
	groupUpdateOnCellEdit:true,
	groupBy:["round","table"],
	groupHeader:[
		function(value, count, data){
			return "Round " + value + "<span style='color:#333; margin-left:10px;'>(" + count + " total players)</span>";
		},
		function(value, count, data){
			return "Table " + value + "<span style='color:#333; margin-left:10px;'>(" + count + "P)</span>";
		}
	],
    columns:[
		{rowHandle:true, formatter:"handle", headerSort:false, frozen:true, width:30, minWidth:30},
		{title:"ID", field:"id", width:60, editor:"number", editorParams:{min:0,max:999999,step:1}, validator:"integer"}, // matchrowid = unique
		{title:"PlayerID", field:"playerid", width:60, editor:"number", editorParams:{min:0,max:500,step:1}, validator:"integer",
		cellEdited: function(cell) {
			// Get the edited player ID value
			let search_id = cell.getValue();
			// Get the row data
			let rowData = cell.getRow().getData();		
			// Use a function to fetch the player name based on the edited player ID
			// Replace getPlayerNameById with your actual data retrieval logic
			let playerName = retrievePlayer4ID(search_id);
			// Update the "PlayerName" field in the row with the new value
			cell.getRow().update({ player: playerName});
		}}, // playerid
		{title:"Player", field:"player", width:120, editor:false}, // change player by changing playerid
		{title:"VP", field:"vp", width:80, editor:"number", editorParams:{min:20,max:500,step:1}, validator:"integer", sorter:"number"},
		{title:"Rank", field:"rank", width:80, editor:"number", editorParams:{min:1,max:6,step:1}, validator:"integer", sorter:"number"},
		{title:"Corp", field:"corp", width:100, formatter:"image", formatterParams:{
			height:"30px",
			width:"80px",
			urlPrefix:"corps/",
			urlSuffix:".png"
			},
			editor:"list", editorParams:{values:{
			"Unknown": "Unknown",
				"Arcadian Communities": "Arcadian Communities",
				"Aridor": "Aridor",
				"Arklight": "Arklight",
				"Astrodrill": "Astrodrill",
				"BeginnerCorp": "Beginner Corp",
				"Cheung Shing Mars": "Cheung Shing Mars",
				"Credicor": "Credicor",
				"Crowdsource": "Crowdsource",
				"Dev Wright": "Dev Wright",
				"Ecoline": "Ecoline",
				"Earth First": "Earth First",
				"Factorum": "Factorum",
				"Helion": "Helion",
				"Interplanetary Cinematics": "Interplanetary Cinematics",
				"Inventrix": "Inventrix",
				"Lakefront Resorts": "Lakefront Resorts",
				"Manutech": "Manutech",
				"Mining Guild": "Mining Guild",
				"Mons Insurance": "Mons Insurance",
				"Morning Star": "Morning Star",
				"Pharmacy Union": "Pharmacy Union",
				"Phobolog": "Phobolog",
				"Philares": "Philares",
				"Polyphemos": "Polyphemos",
				"Point Luna": "Point Luna",
				"Princess Ltd": "Princess Ltd",
				"Pristar": "Pristar",
				"Recyclon": "Recyclon",
				"Robinson Industries": "Robinson Industries",
				"Saturn Systems": "Saturn Systems",
				"Space Penal Colony": "Space Penal Colony",
				"Splice": "Splice",
				"Teractor": "Teractor",
				"Terra Labs": "Terra Labs",
				"Tharsis Republic": "Tharsis Republic",
				"Thorgate": "Thorgate",
				"UNMI": "UNMI",
				"Utopia": "Utopia",
				"Valley Trust": "Valley Trust",
				"Vitor": "Vitor",
				"Viron": "Viron"
			}}},
			//formatter:function(cell, formatterParams){ var value = cell.getValue();},
		{title:"Table", field:"table", width:80, editor:"number", editorParams:{ min:1,max:100,step:1}, validator:"integer", sorter:"number"},
		{title:"Round", field:"round", width:80, editor:"number", editorParams:{ min:1,max:10,step:1}, validator:"integer", sorter:"number"},
    ],
});
// add row
$("#add-match-row").click(function(){
  matchTable.addRow({"id":matchrowid});
	matchrowid++;
	matchTable.redraw();
});
// delete rows
$("#del-match-row").click(function(){
	//var selectedRows = matchTable.getSelectedRows(); // doesnt work anymore
	//for(var i=0;i<selectedRows.length;i++) { selectedRows[i].delete(); }
	//var selectedRows = Array.from(matchTable.getSelectedData(), v => v.id);
	var selectedRows = matchTable.getSelectedRows();
	for(var i=0;i<selectedRows.length;i++) { selectedRows[i].delete(); }

	/*let selected = matchTable.getSelectedRows();
	for (i in selected) { selected[i].delete(); };*/
});
/*
document.getElementById("del-match-row").addEventListener("click", function(){
    let selected = matchTable.getSelectedRows();
    for (i in selected) { selected[i].delete(); };
});
*/
//trigger download of data.json file
$("button#download-match-json").click(function(){
  //matchTable.download("json", "matchData "+Date().toLocaleString().replace(/.*\s(.* \d{2}:\d{2}:\d{2}).*/, "$1")+".json");
	matchTable.download("json", "matchData "+Date().toLocaleString().replace(/(:|GMT.*)/gm, '')+".json");
});
//load json file
$("button#load-match-json").click(function(){
	matchTable.import("json", ".json");
	matchTable.redraw();
});
//undo button
$("button#history-undo").on("click", function(){ matchTable.undo(); });
//redo button
$("button#history-redo").on("click", function(){ matchTable.redo(); });
//Filter errors
$("button#filter-errors").click(function(){
	let filters = matchTable.getFilters();
	if (filters.length == 0) {
		//matchTable.setFilter("vp", "in", ["check vp+rank", "", null]);
		matchTable.setFilter(function (data) {
		  return (
			data.vp === "check vp+rank" ||
			data.vp === "" ||
			data.vp === null ||
			typeof data.vp === "undefined"
		  );
		});
		document.getElementById('filter-errors').innerText = "Clear Filter";
	}	else {
		matchTable.clearFilter();
		document.getElementById('filter-errors').innerText = "Filter Errors";
	};
});

// Google Result Tab
function cleanUpColumnName(columnName) {
    return columnName.replace(/\(.*\)/, '').trim();
};
var googleResultTable = new Tabulator("#googleresult-table", {
	layout:"fitData",
	autoColumns:true,
	autoColumnsDefinitions:function(definitions){
        definitions.forEach((column) => {
			// column.title = cleanUpColumnName(column.title); // ( ) contains corporation etc
            column.editor = true; // add header filter to every column
        });
        return definitions;
    },
	history:true,
	downloadRowRange:"all",
	persistenceID:"googleresulttable1",
	persistence: true,
	editor:true,
	selectable: 1, // 1 means max 1 can be selected at a time
});


// Load google result csv/json
$("button#load-result-csv").click(function(){
	googleResultTable.import("csv", ".csv");
	googleResultTable.redraw();
});
$("button#load-result-json").click(function(){
	googleResultTable.import("json", ".json");
	googleResultTable.redraw();
});
// Download google result as JSON (e.g. after editing)
$("button#download-result-json").click(function(){
	googleResultTable.download("json", "matchData "+Date().toLocaleString().replace(/(:|GMT.*)/gm, '')+".json");
});
$("button#del-result-row").click(function(){
	var selectedRows = googleResultTable.getSelectedRows();
	for(var i=0;i<selectedRows.length;i++) { selectedRows[i].delete(); }
});
// Merge the google result into match, any error is marked accordingly
$("button#merge-into-match").click(function(){
	// Download match premerge
	matchTable.download("json", "matchData "+Date().toLocaleString().replace(/(:|GMT.*)/gm, '')+"PREMERGE.json");
	mergeGoogleResultIntoMatch();
	console.log("Finished merge");
});



// SCORE TAB
var scoreTable = new Tabulator("#score-table", {
	index:"id",
	//layout:"fitDataFill",
	//layout:"fitColumns",
	//resizableColumns:false,
	downloadRowRange:"all",
	layout:"fitColumns",
    columns:[
		{formatter:"rownum", title:"Sort", width:40},
		{title:"ID", field:"id", width:50, download:true},
		{title:"Player", field:"player", width:180, resizable:false},
		{title:"Total", field:"total", resizable:false,
			columns:[{title:"Rank", field:"rank", width:60, resizable:false, validator:"integer", sorter:"number"},
					{title:"TPs", width:60, field:"total_tps", headerSort:false, validator:"integer"}, {title:"Skill", width:80, field:"skill", validator:"numeric", sorter:"number"},{title:"VP", width:60, field:"total_vp", validator:"integer", sorter:"number"}]
		},
		{title:"Round 1", field:"rnd1", resizable:false,
			columns:[{title:"Table", width:50, field:"rnd1_table", headerSort:false}, {title:"VP", width:50, field:"rnd1_vp", headerSort:false},{title:"TP", width:50, field:"rnd1_pts", headerSort:false}, {title:"Corp", width:90, field:"rnd1_corp", headerSort:false, tooltip:true, formatter:"image", formatterParams:{
			height:"30px",
			width:"80px",
			urlPrefix:"corps/",
			urlSuffix:".png"
			},}]
		},
		{title:"Round 2", field:"rnd2", resizable:false,
			columns:[{title:"Table", width:50, field:"rnd2_table", headerSort:false}, {title:"VP", width:50, field:"rnd2_vp", headerSort:false},{title:"TP", width:50, field:"rnd2_pts", headerSort:false}, {title:"Corp", width:90, field:"rnd2_corp", headerSort:false, tooltip:true, formatter:"image", formatterParams:{
			height:"30px",
			width:"80px",
			urlPrefix:"corps/",
			urlSuffix:".png"
			},}]
		},
		{title:"Round 3", field:"rnd3", resizable:false,
			columns:[{title:"Table", width:50, field:"rnd3_table", headerSort:false}, {title:"VP", width:50, field:"rnd3_vp", headerSort:false},{title:"TP", width:50, field:"rnd3_pts", headerSort:false}, {title:"Corp", width:90, field:"rnd3_corp", headerSort:false, tooltip:true, formatter:"image", formatterParams:{
			height:"30px",
			width:"80px",
			urlPrefix:"corps/",
			urlSuffix:".png"
			},}]
		}
    ],
});

//trigger download of data.json file or pdf file
$("button#download-score-json").click(function(){ scoreTable.download("json", "scoreData "+Date().toLocaleString().replace(/(:|GMT.*)/gm, '')+".json"); });

// Update score table and re-rank
$("button#compute-score").click(function(){ updateScoreTable(); });
// Pick a random player from the list, prompt the player
$("button#lottery").click(function(){
	updateScoreTable(); // Make sure all rows are correct and ranked;
	scoreTable.deselectRow(); // deselect all
	let active_players = getActivePlayers();
	shuffle(active_players);
	for (pid of active_players) {
		console.log('check winner', pid);
		if (pid2Rank(pid) > 3) {
			let winner = scoreTable.getData().filter(v => v.id == pid)[0];
			scoreTable.selectRow(scoreTable.getRows().filter(row => row.getData().id == pid));
			$("<div title='Winner!'><b>"+winner.rank+". "+winner.player+"</b></div>").dialog({position: 'center'});
			break;
		};
	};
});


var corpTable = new Tabulator("#corp-table", {
	index:"corp",
	//layout:"fitDataFill",
	//layout:"fitColumns",
	//resizableColumns:false,
	layout:"fitColumns",
    columns:[
		{formatter:"rownum", title:"Sort", width:40, headerSort:false},
		{title:"Corp", width:100, field:"corp", tooltip:true, formatter:"image", formatterParams:{
			height:"30px",
			width:"80px",
			urlPrefix:"corps/",
			urlSuffix:".png"
			},
		},
		{title:"Stats", field:"stats", resizable:false,
			columns:[{title:"AvgRank", width:100, field:"avg_rank"}, {title:"Skill", width:100, field:"corp_skill"}, {title:"Picked", width:100, field:"total_picked"}]
		},
		{title:"Picked", field:"picked", resizable:false,
			columns:[{title:"R1", width:50, field:"rnd1_picked", headerSort:false}, {title:"R2", width:50, field:"rnd2_picked", headerSort:false}, {title:"R3", width:50, field:"rnd3_picked", headerSort:false}]
		},
		{title:"Rank", field:"rank", resizable:false,
			columns:[{title:"1ST", width:50, field:"rank_1", headerSort:false}, {title:"2ND", width:50, field:"rank_2", headerSort:false}, {title:"3RD", width:50, field:"rank_3", headerSort:false}, {title:"4TH", width:50, field:"rank_4", headerSort:false}]
		},
    ],
});
$("button#download-corp-json").click(function(){
  corpTable.download("json", "corpData "+Date().toLocaleString().replace(/(:|GMT.*)/gm, '')+".json");
});
$("button#compute-corp").click(function(){
	updateCorpTable();
	corpTable.setSort([{column:"corp_skill", dir:"desc"}]);
	corpTable.redraw();
});


// CROSS LOGIC
//Compute which round we are in, using the match data
// 0 is pre-start, 1-3 are rounds, no >3 rounds (unless we want to change)
function fncRound() {
	let rnd = 0;
	let matchData = matchTable.getData();
	for (var i = 0; i < matchData.length; i++) { if (matchData[i]["round"] > rnd) { rnd = matchData[i]["round"]; }; }; // 0 refers to the round number from the string.
	return parseInt(rnd);
}

// Shuffle function
function shuffle(array) {
  array.sort(() => Math.random() - 0.5);
};

// Table ranker in Match
function tablerank(table_array) {
	table_array.sort(function (r1, r2) {
		// Sort by points
		if (r1.vp > r2.vp) return -1;
		if (r1.vp < r2.vp) return 1;

		// In case of ties, use the rank
		// Be wary of ties!
		if (r1.rank === undefined || r1.rank === null || r2.rank === undefined || r2.rank === null || r1.rank == r2.rank) {
			showedWarning = true;
				matchTable.updateData([{id:r1.id,vp:'check vp+rank'}, {id:r2.id, vp:'check vp+rank'}]);
			return; };
		if (r1.rank < r2.rank) return -1;
		if (r1.rank > r2.rank) return 1;
	});
	return table_array;
};

// Identify subgraphs
function difference(setA, setB) {
    var _difference = new Set(setA);
    for (var elem of setB) {
        _difference.delete(elem);
    }
    return _difference;
};
function union(setA, setB) {
	return [...new Set([...setA, ...setB])];
};
function intersect(setA, setB) {
  return setA.filter((element) => setB.includes(element));
}
function intersectArr(arrA, arrB) {
	return arrA.filter(function(n) {
		return arrB.indexOf(n) > -1;
	});
};
function playersOnTable(rnd, table, data) {
	return Array.from(data.filter(row => row.round == rnd && row.table == table), v=>v['playerid']);
};
function opponentsOfPlayer(pid, data) {
	let playerRows = data.filter(row => row.playerid == pid);
	let players = [];
	for (let r of playerRows) {
		players = players.concat(playersOnTable(r.round, r.table, data));
	};
	players = players.filter(player => player !== pid); // exclude the player itself
	return Array.from(new Set(players));
};
function subgraphs(data) {
	// This approach is an 'after the fact' check rather than keeping tracks as we progress through the tournament, because players may seat a different table than expected.
	// Input is a matchTable dataset, allowing for the checking of assignment solutions
	let result = []; // holds subgraphs
	// Players that we are going to check:
	//let uniquePlayers = Array.from(new Set(Array.from(data, v=>v['playerid'])));
	let uniquePlayers = union(Array.from(new Set(Array.from(data, v=>v['playerid']))), getActivePlayers()); // include players that are new
	while (uniquePlayers.length > 0) {
		let current_player = uniquePlayers.pop();
		let current_subgraph = new Set([current_player]);
		let related = opponentsOfPlayer(current_player, data);
		while (related.length > 0) {
			// pop first related
			check = related.pop();
			// add to current_subgraph
			current_subgraph = union(current_subgraph, [check]);
			// delete from uniquePlayers
			//uniquePlayers = Array.from(difference(uniquePlayers, [check]));
			uniquePlayers = uniquePlayers.filter(playerid => playerid !== check);
			// add opponents of this player to related if they are not yet in current_subgraph, and only those that have not already been in related
			related = Array.from(union(related, difference(opponentsOfPlayer(check, data), current_subgraph)));
		};
		result.push(Array.from(current_subgraph));
	};
	return result;
};
function deepCopyArray(arr) {
	if (!Array.isArray(arr)) {
		return arr; // Base case: if the input is not an array, return it as is
	}
	let copy = [];
	for (let i = 0; i < arr.length; i++) {
		copy[i] = deepCopyArray(arr[i]); // Recursively deep copy each element
	}
	return copy;
}


// Value Iteration
function value_iteration(s, skill_graph) {
	// Initialize:
	let skill_dict = {};
	// player of subgraph
	for (p of s) {
		skill_dict[p] = 0;
	};
	// Value iteration
	let its = 0;
	let new_skill_dict = {};
	do {
		change = 0; // change this iteration
		for (p of s) {
			let new_skill = 0;
			for (o in skill_graph[p]) { // for each opponent of the player
				// Q(p) = avg(Diff[p,o]) + Q[o]  === Skill of player is average difference to other players + their skills
				new_skill = new_skill + (skill_graph[p][o].reduce((a,b) => a+b, 0) / skill_graph[p][o].length) + skill_dict[o];
			};
			new_skill = new_skill / Object.keys(skill_graph[p]).length; // average across players
			change += Math.abs(skill_dict[p] - new_skill); // keeping track off delta
			new_skill_dict[p] = new_skill;
		};
		for (p of s) {
			skill_dict[p] = new_skill_dict[p]; // update estimated skill values
		};
		its++; // increment iteration
	} while (change > 1e-5 && its < 250); // repeat the do-while until change is tiny or more than 250 iterations (only happens with big tournaments)
	console.log("Current Round", fncRound(), "Subgraph", s, "Iterations ", its, ", Change ", change);
	return skill_dict;
}

//Update Score Table
function updateScoreTable() {
	let matchData = matchTable.getData();
	// fill in all match points
	let current_round = fncRound();
	console.log("current rnd "+current_round);
	let skill_graph = {}; // VI Skill, who seen who
	let update_matchData = []; // Updates
	for (i = current_round; i > 0; i--) { // Walk back in rounds
		// Rank Tables and create skill_graph
		let uniqueTables = Array.from(new Set(Array.from(matchData.filter(row => row.round == i), v=>v['table'])));
		for (let table of uniqueTables) {
			let foundRows = matchData.filter(row => row.round == i && row.table == table);
			if (foundRows.length < 3) {
				// If less than 3 players, then the ranking has to be entered manually for points
				console.log(table, 'has less than 3 players');
			} else {
				foundRows = tablerank(foundRows);
				for (let ri in foundRows) {
					update_matchData.push({
						id:foundRows[ri].id,
						rank:parseInt(ri)+1
					});
				};
			};

			// Value Iteration differences
			for (let p = 0; p < foundRows.length; p++) {
				for (let o = 0; o < foundRows.length; o++) {
					if (p!=o) {
						if (skill_graph[foundRows[p].playerid]) {
							if (skill_graph[foundRows[p].playerid][foundRows[o].playerid]) {
								// if already a matchup, then add to the list
								skill_graph[foundRows[p].playerid][foundRows[o].playerid].push(foundRows[p].vp - foundRows[o].vp);
							} else {
								// if no matchup yet then add
								skill_graph[foundRows[p].playerid][foundRows[o].playerid] = [foundRows[p].vp - foundRows[o].vp];
							};
						} else {
							// does not yet exist, therefore create
							skill_graph[foundRows[p].playerid] = {};
							skill_graph[foundRows[p].playerid][foundRows[o].playerid] = [foundRows[p].vp - foundRows[o].vp];
							// doesnt work for some reason hence in two steps skill_graph[foundRows[p].playerid] = { foundRows[o].playerid : [foundRows[p].vp - foundRows[o].vp] };
						};
					};
				};
			};
		};
	};
	matchTable.updateOrAddData(update_matchData);
	update_matchData = [];

	// Round VPs
	matchData = matchTable.getData();
	let update_scoreTable = [];
	for (let row of matchData) {
		let i_rnd = row['round'];
		let roundNumber = `rnd${i_rnd}`;
		update_scoreTable.push({
			id: row.playerid,
			player: row.player,
			[`${roundNumber}_table`]: parseInt(row.table),
			[`${roundNumber}_vp`]: parseInt(row.vp),
			[`${roundNumber}_pts`]: rank_scores[parseInt(row.rank)],
			[`${roundNumber}_corp`]: row.corp || "Unknown"
		});
		/*
		if (i_rnd == 1) {
			update_scoreTable.push({
				id:row.playerid,
				player:row.player,
				rnd1_table:parseInt(row.table),
				rnd1_vp:parseInt(row.vp),
				rnd1_pts:rank_scores[parseInt(row.rank)],
				rnd1_corp:row.corp || "Unknown"
			});
		} else if (i_rnd == 2) {
			update_scoreTable.push({
				id:row.playerid,
				player:row.player,
				rnd2_table:parseInt(row.table),
				rnd2_vp:parseInt(row.vp),
				rnd2_pts:rank_scores[parseInt(row.rank)],
				rnd2_corp:row.corp || "Unknown"
			});
		} else if (i_rnd == 3) {
			update_scoreTable.push({
				id:row.playerid,
				player:row.player,
				rnd3_table:parseInt(row.table),
				rnd3_vp:parseInt(row.vp),
				rnd3_pts:rank_scores[parseInt(row.rank)],
				rnd3_corp:row.corp || "Unknown"
			});
		} else {
			console.log('error in updating vps and table');
		};
		*/
	};
	matchTable.redraw();
	scoreTable.updateOrAddData(update_scoreTable);

	// Total Points + Total VPs
	let scoreData = scoreTable.getData();
	update_scoreTable = [];
	for (var i in scoreData) {
		update_scoreTable.push({
			id:scoreData[i].id,
			player:scoreData[i].player,
			total_tps:(scoreData[i].rnd1_pts || 0)+(scoreData[i].rnd2_pts || 0)+(scoreData[i].rnd3_pts || 0),
			total_vp:(scoreData[i].rnd1_vp || 0)+(scoreData[i].rnd2_vp || 0)+(scoreData[i].rnd3_vp || 0)
		});
	};
	scoreTable.updateOrAddData(update_scoreTable);

	// Skill Estimator
	// Need to identify subgraphs and of those the minimum, which then uplifts the whole subgraph for the same translation
	let subs = subgraphs(matchTable.getData());
	update_scoreTable = [];

	// Value Iteration solution
	// For each subgraph, do value iteration (separately)
	for (s of subs) {
		// If only one player in the subgraph then just set its skill to 0.
		if (s.length == 1) {
			update_scoreTable.push({
				id:s[0],
				skill:0
			});
			continue;
		};

		// Get skill estimates within subgraph
		skill_dict = value_iteration(s, skill_graph);

		// Normalize within subgraph
		let lowest = 0 - Math.min.apply(null, s.map(x => skill_dict[x]));
		for (p of s) {
			update_scoreTable.push({
				id:p,
				skill:(skill_dict[p] + lowest).toFixed(3) // it approximates and hence about 0.002 difference per rerun
			});
		};
	};
	scoreTable.updateOrAddData(update_scoreTable);

	// Sort
	scoreTable.setSort([
		{column:"total_vp", dir:"desc"}, //sort by this first
		{column:"skill", dir:"desc"}, //then sort by this second
		{column:"total_tps", dir:"desc"}, //then sort by this third
	]);
	// Rank
	scoreData = scoreTable.getData('active'); // use as the way it is sorted
	update_scoreTable = [];
	let ranker = 1;
	for (let i = 0; i < scoreData.length; i++) {
		if (playerTable.getData().filter(r => r.id == scoreData[i].id)[0].present == true) {
			update_scoreTable.push({
				id:scoreData[i].id,
				rank:ranker
			});
			ranker++;
		} else {
			update_scoreTable.push({
				id:scoreData[i].id,
				rank:'999 EXIT',
				total_tps:0 // added to make sure it comes at bottom
			});
		};
	};
	scoreTable.updateOrAddData(update_scoreTable);
	// Make sure it is sorted properly, with EXITs at bottom
	scoreTable.setSort([
		{column:"total_vp", dir:"desc"}, //sort by this first
		{column:"skill", dir:"desc"}, //then sort by this second
		{column:"total_tps", dir:"desc"}, //then sort by this third
	]);
	scoreTable.redraw();
};

function pid2Rank(pid) {
	return scoreTable.getData().filter(row => row.id == pid)[0].rank;
};
function pid2TP(pid) {
	let row = scoreTable.getData().find(row => row.id === pid);
	return row ? row.total_tps : 0; // if no scores then 0
};

// for testing purposes:
function getRndInteger(min, max) {
  return Math.floor(Math.random() * (max - min + 1) ) + min;
};

// Add players to match table for new round
function players2Match(current_round) {
	// current_round is the to be added round
	let playerList = getActivePlayers();
	let num_leftover_players = playerList.length % 4;
	let num_tables = Math.ceil(playerList.length / 4);
	let num_complete_tables = Math.max(0,num_tables - Math.abs((4-num_leftover_players) % 4));
	if (current_round == 0 || current_round === undefined || current_round == false) {
		window.alert('Incorrect usage players2Match');
	} else if (current_round > TOURNAMENT_MAX_ROUNDS) {
		console.log("Game has a limit of ", TOURNAMENT_MAX_ROUNDS, " rounds");
	} else if (current_round == 1) {
		// Assign round 1
		// Just shuffle and assign randomly
		shuffle(playerList);
		let onTable = 0;
		let current_table = 1;
		let current_pid = -1;
		let update_matchData = [];
		while (playerList.length > 0) {
			current_pid = playerList.pop();
			update_matchData.push({
				"id": matchrowid, "round": current_round, "table": current_table,
				"player": retrievePlayer4ID(current_pid), "playerid":current_pid,
				"corp": 'Unknown'
				//"vp": getRndInteger(40,100) // TEST***
			});
			matchrowid++;
			onTable++;
			if ( (current_table <= num_complete_tables && onTable == 4) || (current_table > num_complete_tables && onTable == 3) ) {
				onTable = 0;
				current_table++;
			};
		};
		matchTable.addData(update_matchData);
	} else { //if (current_round <= TOURNAMENT_MAX_ROUNDS) {
		// Assign rounds 2 and 3
		// In order to have all players connected by round 3, we check if there is a solution
		let update_matchData = [];
		let attempts = MAX_ATTEMPTS_ASSIGNTABLES;
		let best_assignment = null;
		let best_score = Infinity;
		// New Approach: if you take each round players with the most TP, that means you implicitly are mixing the subgraphs
		// Hence: get TP groups, shuffle within each TR group and then from most TP to lowest, add players, skipping players that were already seen by players in the pool?
		// 0. Rank players
		updateScoreTable(); // this is required to rank players in pid2Rank
		let matchData = matchTable.getData();
		// 1. Get groups of TPs
		let grpTPs = Array.from({ length: (current_round - 1)*rank_scores[0] + 1 }, () => []);
		playerList.forEach((pid) => {
		  let points = pid2TP(pid);
		  grpTPs[points].push(pid);
		});
		// and reverse, from highest to lowest TP
		grpTPs.reverse()
		// 2. Try assignments
		while (attempts > 0) {
			let this_assignment = [];
			let this_score = 0;
			// 3. Create a copy of grpTPs
			let this_copy = deepCopyArray(grpTPs);
			// 4. Shuffle within each group
			this_copy.forEach((subarray) => {
			  shuffle(subarray);
			});
			// 5. Assign tables
			let onTable = 0;
			let current_table = 1;
			let playersranked = this_copy.flat(1); // flatten
			let thistable = [];
			for (let pid of playersranked) {
				this_assignment.push({
					"id": matchrowid, "round": current_round, "table": current_table,
					"player": retrievePlayer4ID(pid), "playerid":pid,
					"corp": 'Unknown'
					//"vp": getRndInteger(40,100) // TEST***
				});
				thistable.push(pid);
				matchrowid++;
				onTable++;
				// check if pid has seen any of his opponents and penalize for each repeat
				this_score += intersectArr(opponentsOfPlayer(pid, matchData), thistable).length**2;
				// check if table is full:
				if ( (current_table <= num_complete_tables && onTable == 4) || (current_table > num_complete_tables && onTable == 3) ) {
					onTable = 0;
					current_table++;
					thistable = [];
				};
			};
			// check if it is better than best assignment
			attempts--;
			if (this_score < best_score) {
				best_assignment = this_assignment;
				best_score = this_score;
			};
			if (best_score == 0) {
				break;
			};
		}; // # end while attempts
		console.log("Best score", best_score);
		matchTable.addData(best_assignment);
	}; // future rounds
	matchTable.setSort([
		{column:"table", dir:"asc"}, //sort by this first
		{column:"round", dir:"asc"}, //then sort by this second
	]);
	matchTable.redraw();
};

// Create a new round
$("#start-new-round").on("click", function(){
	// check which round we are already in
	// if at start, then populate
	// if at any round, then check if all values are entered, and all names in player list exist in round
	let current_round = fncRound();
	console.log("current round "+current_round);
	let playerList = getActivePlayers();
	if (current_round == 0 && playerList.length > 2) {
		//shuffle(playerList);
		console.log('Start tournament, first round:');
		console.log(playerList);
		console.log("within current round code "+current_round);
		// Add Players to Round 1
		players2Match(1);
		// Update round indicator
		$("#round-indicator").text(fncRound());
	} else if (current_round < 3 && playerList.length > 2) {
		let matchData = matchTable.getData();
		let matchPlayers = Array.from(matchData, v => v["playerid"]);

		// Missing players not working correctly it seems. Not check if player is active or not, and when starting new round then the match should have added for that round rather
		/*
		// Check if any new players were added that were not assigned any table, warn about them, and add to tournament
		let missing_players = $.grep(playerList, function(el){return $.inArray(el, matchPlayers) == -1});
		let missing_players_names = missing_players.map(pid => retrievePlayer4ID(pid));
		if (missing_players.length > 0) {
			if (missing_players_names.length > 1) {
				window.alert('New players were not assigned any tables: '+missing_players_names.slice(0, missing_players_names.length - 1).join(', ') + ", and " + missing_players_names.slice(-1));
			} else if (missing_players_names.length == 1) {
				window.alert('New player was not assigned any tables: '+missing_players_names.slice(0));
			};
			// Add missing players
			for (i = current_round; i > 0; i--) {
				for (let missed_player of missing_players) {
					console.log('yep');
					matchTable.addRow({"id":matchrowid, "round": i, "playerid":missed_player, "player":retrievePlayer4ID(missed_player)});
					matchrowid++;
				};
			};
			return;
		};
		*/
		// Missing scores table
		if (matchData.some(element => element['vp'] === null || element['vp'] === undefined || !Number.isInteger(element['vp']))) {
			window.alert('Not all VPs have been entered for this round!');
			return;
		};
		// Missing table IDs
		if (matchData.some(element => element['table'] === null || element['table'] === undefined || !Number.isInteger(element['table']))) {
			window.alert('Not all Players have correct Tables!');
			return;
		};
		// Incorrect number of players per table
		for (i = current_round; i > 0; i--) {
			let uniqueTables = Array.from(new Set(Array.from(matchData.filter(row => row.round == i), v=>v['table'])));
			console.log(uniqueTables);
			for (let table of uniqueTables) {
				let foundRows = matchData.filter(row => row.round == i && row.table == table);
				if (foundRows.length > 4) {
					if (!confirm('Table '+table+' in Round '+i+' has more than 4 players! Is this correct?')) {
						window.alert('Please change Table '+table+' in Round '+i);
						return;
					};
				} else if (foundRows.length < 3) {
					if (!confirm('Table '+table+' in Round '+i+' has less than 3 players! Is this correct?')) {
						window.alert('Please change Table '+table+' in Round '+i);
						return;
					};
				};
			};
		};
		// No players missing & all scores entered:
		players2Match(current_round + 1);
		// Update round indicator
		$("#round-indicator").text(fncRound());
		matchTable.download("json", "matchData "+Date().toLocaleString().replace(/(:|GMT.*)/gm, '')+"AUTO.json");
	} else if (playerList.length < 3) {
		window.alert("Insufficient players were found. Please make sure all players are present.");
	} else if (current_round >= 3) {
		console.log(current_round);
		window.alert("Already at last round 3. Tournament has finished.");
	};

});

function decide_round(v) {
	switch(v) { case 1: return 'rnd1'; break; case 2: return 'rnd2'; break; case 3: return 'rnd3'; break; };
};

function updateCorpTable() {
	let matchData = matchTable.getData();
	let updateCorpDict = {};
	for (r of matchData) {
		if (!updateCorpDict[r.corp]) {
			updateCorpDict[r.corp] = {};
		};
		updateCorpDict[r.corp]['corp'] = r.corp;
		updateCorpDict[r.corp][decide_round(r.round) + '_picked'] = (updateCorpDict[r.corp][decide_round(r.round) + '_picked'] || 0) + 1; // add picked count
		updateCorpDict[r.corp]['rank_'+r.rank] = (updateCorpDict[r.corp]['rank_'+r.rank] || 0) + 1; // add rank count
	};
	let updateCorpArray = [];
	// Update aggregates and fill zeros
	for ( [corp, record] of Object.entries(updateCorpDict) ) {
		record['rnd1_picked'] = record['rnd1_picked'] || 0;
		record['rnd2_picked'] = record['rnd2_picked'] || 0;
		record['rnd3_picked'] = record['rnd3_picked'] || 0;
		record['rank_1'] = record['rank_1'] || 0;
		record['rank_2'] = record['rank_2'] || 0;
		record['rank_3'] = record['rank_3'] || 0;
		record['rank_4'] = record['rank_4'] || 0;
		record['total_picked'] = record['rnd1_picked'] + record['rnd2_picked'] + record['rnd3_picked'];
		//updateCorpTable[corp]['avg_rank'] = (record['rank_1'] || 0) +
		record['avg_rank'] = (( 1*record['rank_1'] + 2*record['rank_2'] + 3*record['rank_3'] + 4*record['rank_4'] ) / record['total_picked']).toFixed(2);
		updateCorpArray.push(record);
	};
	corpTable.updateOrAddData(updateCorpArray);

	// Calculate Skill:
	let skill_graph = {}; // VI Skill
	for (i = 1; i <= 3; i++) {
		let uniqueTables = Array.from(new Set(Array.from(matchData.filter(row => row.round == i), v=>v['table'])));
		for (let table of uniqueTables) {
			let foundRows = matchData.filter(row => row.round == i && row.table == table);
			// Value Iteration differences
			for (let p = 0; p < foundRows.length; p++) {
				for (let o = 0; o < foundRows.length; o++) {
					if (p!=o && foundRows[p].corp != 'Unknown' && foundRows[o].corp != 'Unknown') {
						if (skill_graph[foundRows[p].corp]) {
							if (skill_graph[foundRows[p].corp][foundRows[o].corp]) {
								// if already a matchup, then add to the list
								skill_graph[foundRows[p].corp][foundRows[o].corp].push(foundRows[p].vp - foundRows[o].vp);
							} else {
								// if no matchup yet then add
								skill_graph[foundRows[p].corp][foundRows[o].corp] = [foundRows[p].vp - foundRows[o].vp];
							};
						} else {
							// does not yet exist, therefore create
							skill_graph[foundRows[p].corp] = {};
							skill_graph[foundRows[p].corp][foundRows[o].corp] = [foundRows[p].vp - foundRows[o].vp];
							// doesnt work for some reason hence in two steps skill_graph[foundRows[p].corp] = { foundRows[o].corp : [foundRows[p].vp - foundRows[o].vp] };
						};
					};
				};
			};
		};
	};
	console.log(skill_graph);

	updateCorpArray = [];
	// Value Iteration solution	(just do all at once rather than per subgraph)

	// Value iteration
	skill_dict = value_iteration(Object.keys(skill_graph), skill_graph); // for corps all in one go
	// Normalize within sub
	let lowest = 0 - Math.min.apply(null, Object.keys(skill_dict).map(x => skill_dict[x]));
	for (c of Object.keys(skill_dict)) {
		updateCorpArray.push({
			corp:c,
			corp_skill:(skill_dict[c] + lowest).toFixed(3) // it approximates and hence about 0.002 difference
		});
	};
	corpTable.updateOrAddData(updateCorpArray);

};

function mergeGoogleResultIntoMatch() {
	// Merges googleresult into match Table
	//let match2GoogleMapping = {
	//	table: 'Table Number', // Replace with actual column names
	//	round: 'Round',
	//};
	let match2GoogleKeys = ['table','round','playerid'];
	
	let rowPlayers = [];
	let googleResultData = googleResultTable.getData();
	let matchData = matchTable.getData();
	// Split each row into different player details
	let rankmap = {1: 'Winner', 2: '2nd', 3: '3rd', 4: '4th', 5: '5th', 6: '6th'};
	googleResultData.forEach(function (row) {
		// winner because different name structure
		let playerObject = {
				"rank": 1,
				"playerid": parseInt(row["Winner (player number, not name)"]),
				"player": retrievePlayer4ID(parseInt(row["Winner (player number, not name)"])),
				"vp": parseInt(row["Winner (Victory Points)"]),
				"corp": row["Winner (corporation played)"],
				"table": parseInt(row["Table Number (number)"]),
				"round": parseInt(row["Round (number)"])
				//"Map": originalData["Map"]
		};
		rowPlayers.push(playerObject);
		// Create objects for 1-4 places (5/6 as precaution)
		for (let i = 2; i <= 6; i++) {
			let rankname = rankmap[i];
			if (!(rankname + " place (player number, not name)" in row) || 
				row[rankname + " place (player number, not name)"].trim() === "") {
				break; // no more players
			}
			let playerObject = {
				"rank": i,
				"playerid": parseInt(row[rankname + " place (player number, not name)"]),
				"player": retrievePlayer4ID(parseInt(row[rankname + " place (player number, not name)"])),
				"vp": parseInt(row[rankname + " place (Victory Points)"]),
				"corp": row[rankname + " place (corporation played)"],
				"table": parseInt(row["Table Number (number)"]),
				"round": parseInt(row["Round (number)"])
				//"Map": row["Map"]
			};
			rowPlayers.push(playerObject);
		}
	});
	
	
	// Merge data from split google result into matchTable
	let updateDataArray = [];
	rowPlayers.forEach(function (row1) {
		let matchingRow = matchData.find(function (row2) {
			// Check if the columns specified in the mapping match
			for (let col of match2GoogleKeys) {
				if (row2[col] !== row1[col]) {
					return false;
				}
			}
			return true;
		});
		if (matchingRow === undefined) {
			console.log("Could not find matching row for ", row1);
		} else if (matchingRow) {
			// Inherit the matchrowid and then take everything from the split googleresult
			let updateObject = Object.assign({id:matchingRow['id']}, row1);
			updateDataArray.push(updateObject);
		} else {
			// Handle cases where there's no match in table2
			// You can decide how to handle these cases
			console.log("Could not find matching row for ", row1);
		}
	});
	console.log(updateDataArray);

	// Update matchData with the found data
	matchTable.updateData(updateDataArray);
};

</script>
</body>
</html>
